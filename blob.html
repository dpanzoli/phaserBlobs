
<html>
<meta charset="utf-8">
<script src="phaser.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script>

var socket = io();

socket.on('update', function(msg) {
	console.log();
});

var config = {
    type: Phaser.WEBGL,
    width: 800,
    height: 800,
    backgroundColor: '#000',
    parent: 'phaser-example',
    scene: {
        preload: preload,
        create: create,
		update: update
    },
	physics: {
        default: 'arcade',
        arcade: {
            debug: false
        }
    },
};

var game = new Phaser.Game(config);

var avatar, directionArrow;

function preload ()
{
    this.load.atlas('flares', 'flares.png', 'flares.json');
	this.load.spritesheet('faces','faces.png', { frameWidth: 64, frameHeight: 64 });
	
	this.load.spritesheet('arrow','arrow.png',{ frameWidth: 50, frameHeight: 80 });
}


var blobs = {
	petit: {
		body: 32,
		scale: 0.4,
		emitter: {
			color: 'yellow',
			quantity:20,
			lifespan: 300,
			radius: 20,
			scale: 0.3
		},
		arrow: {
			distance:  40,
			frame: {normal: 2, charge: 5}
		}
	},
	moyen: {
		body: 32,
		scale: 0.6,
		emitter: {
			color: 'green',
			quantity:10,
			lifespan: 500,
			radius: 25,
			scale: 0.5
		},
		arrow: {
			distance: 50,
			frame: {normal: 1, charge: 4}
		}
	},
	gros: {
		body: 50,
		scale: 1,
		emitter: {
			color: 'blue',
			quantity:10,
			lifespan: 1000,
			radius: 25,
			scale: 1
		},
		arrow: {
			distance: 80,
			frame:  {normal: 0, charge: 3}
		}
		
	}
}

var blob =0; //blob en cours d'affichage

function create ()
{
    var particles = this.add.particles('flares');
	var blobGroup = this.physics.add.group({
		bounceX: 1,
		bounceY: 1,
		collideWorldBounds: true
	});
	
	b = Object.keys(blobs)[blob];

	avatar = this.add.container(400,300);
	this.physics.world.enable(avatar);
	avatar.vitesse = 0;
	avatar.direction = 0;
	avatar.body.setCircle(blobs[b].body,-blobs[b].body,-blobs[b].body);
	blobFace = this.add.image(0, 0, 'faces',0);
	blobFace.setScale(blobs[b].scale);
	blobFace.emitter = particles.createEmitter({
		frame:  [blobs[b].emitter.color],
		quantity: blobs[b].emitter.quantity,
        lifespan: blobs[b].emitter.lifespan,
        blendMode: 'ADD',
		emitZone: {source: new Phaser.Geom.Circle(0, 0, blobs[b].emitter.radius)},
		follow : avatar,
		scale: { start: blobs[b].emitter.scale, end: 0, ease: 'linear' }
    });
	blobGroup.add(avatar);
	avatar.add(blobFace);
	//ajout de la flèche de contrôle
	var controlArrow = this.add.container(0,0);
	controlArrow.visible = false; //par défaut
	directionArrow = this.add.image(0,0,'arrow');
	directionArrow.setFrame(blobs[b].arrow.frame.normal);
	controlArrow.add(directionArrow);
	avatar.add(controlArrow);
	
	this.input.on('pointermove', function (pointer) {
		
		avatar.direction = Phaser.Math.Angle.Between(
			avatar.x,
			avatar.y,
			pointer.worldX,
			pointer.worldY
		);
		controlArrow.setRotation(avatar.direction);
		
		var distance = Phaser.Math.Distance.Between(
			avatar.x,
			avatar.y,
			pointer.worldX,
			pointer.worldY
		);
		var db = blobs[b].arrow.distance
		if (distance<db) {
			controlArrow.visible = false;
			avatar.vitesse = 0;
		} else {
			controlArrow.visible = true;
			var norm = (Math.min(distance,db*4) - db)/(db*4)
			//modifier la taille de la flèche
			directionArrow.setScale(norm*0.75+0.25);
			//modifier la distance de la flèche
			directionArrow.x = blobs[b].arrow.distance + (norm*50);
			avatar.vitesse = norm;
		}
	});
	
	this.input.keyboard.on('keydown_SPACE', function (event) {
		event.stopPropagation();
		blob = (blob + 1) % Object.keys(blobs).length;
		this.scene.restart();
    }, this);

}

function update(elapsed, delta) {
	
	if (this.input.activePointer.isDown && avatar.vitesse > 0.5) {
		directionArrow.setTint(0xff0000);
		blobFace.setFrame(2);
		this.physics.velocityFromRotation(
			avatar.direction, 
			avatar.vitesse*delta*50,
			avatar.body.velocity
		);
	} else {
		directionArrow.clearTint();
		if (avatar.vitesse > 0.3) {
			//move fast
			blobFace.setFrame(1);
		} else {
			//move slowly
			blobFace.setFrame(0);
		}
		this.physics.velocityFromRotation(
			avatar.direction, 
			avatar.vitesse*delta*25,
			avatar.body.velocity
		);
	}
	socket.emit('blobmove', {
		position: avatar.position
	});
	
	
}


</script>

</html>